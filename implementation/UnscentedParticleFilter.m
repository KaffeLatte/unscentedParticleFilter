clc
% Formulate prior

t_max = 1000;
x0 = 1; % TODO : change to random value.
[xt_prior,yt_prior] = generateData(t_max,x0); % dim(xt) = 1x(t_max+1)

% To begin with, we set the prior to a normal distribution, generated by taking the mu and
% sigma from 1000 datapoints. 
% Another thought: maybe we should do this to get the prior but only on our
% real data points.

pd = fitdist(xt_prior,'Normal');
prior_mu = pd.mu;
prior_sigma = pd.sigma;
%% UPF Algorithm
clc
% Step 1, t = 0.
N = 200;
%N = 10;

% Create a P0 that is a scalar. Therefore the transposes are not that
% important.
particles = normrnd(prior_mu, prior_sigma, N, 1); % 200x1
v0 = zeros(N,1);
n0 = zeros(N,1);
estimated_x = mean(particles) % scalar
P0 = var(particles) % scalar

x_a = [particles, v0, n0]; % 200x3
estimated_x_a = [estimated_x, mean(v0), mean(n0)] % 1x3

%estimated_x_a_duplicates = repmat(estimated_x_a,N,1); % 200x3
%diffs = x_a - estimated_x_a_duplicates; % 200x3
%P0_a = diffs'*diffs


%% Create a P0 that is 200x200
clc
% Step 1, t = 0.
N = 200;
%N = 10;
particles = normrnd(prior_mu, prior_sigma, N, 1); % 200x1
v0 = zeros(N,1);
n0 = zeros(N,1);
estimated_x = mean(particles); % scalar

diffs = particles - estimated_x; % 200x1
P0 = diffs*diffs'; % 200x200
x_a = [particles, v0, n0];
% estimated_x_a = [estimated_x', 0, 0]';





