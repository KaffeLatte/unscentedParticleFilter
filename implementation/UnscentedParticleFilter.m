%% Generate data part
clear all
clc
close all
t_max = 60;
x0 = 1; % TODO : change to random value.
[xt,yt] = generateData(t_max, x0);


%% Formulate prior
clc

%TODO: talk about this prior to Hedvig, is it to good?
number_of_samples = 1000;
x0 = 1; % TODO : change to random value.
[xt_prior,yt_prior] = generateData(number_of_samples,x0); % dim(xt) = 1x(t_max+1)

% To begin with, we set the prior to a normal distribution, generated by taking the mu and
% sigma from 1000 datapoints. 
% Another thought: maybe we should do this to get the prior but only on our
% real data points.

pd = fitdist(xt_prior,'Normal');
prior_mu = pd.mu
prior_sigma = pd.sigma

%% UPF Algorithm
% Repeat the experiment 100 times.
clc
% Set the number of time steps
T = 60;

% Set the number of particles
%N = 200;
N = 10;

% Step 1. t = 0.
% Draw particles from the prior
particles = normrnd(prior_mu, prior_sigma, N, 1); % 200x1
% Initiate noise variables
v0 = zeros(N,1);
n0 = zeros(N,1);
% Compute mean
estimated_x = mean(particles); % scalar
% Copute Covariance matrix.
diffs = particles - estimated_x; % 200x1
P0 = diffs'*diffs; % 1x1
% Redefine the state rand var as a concatenation of the original state and
% noise variables.
x_a = [particles, v0, n0]; % 200x3
% Compute the "new" mean
estimated_x_a = [estimated_x, mean(v0), mean(n0)]; % 1x3
% Compute the "new" Covariance matrix.
estimated_x_a_duplicates = repmat(estimated_x_a,N,1); % 200x3
diffs = x_a - estimated_x_a_duplicates; % 200x3
P0_a = diffs'*diffs; % 3x3

% Step 2. t = 1,...,60
alpha = 1;
beta = 0;
kappa = 2;
n_x = size(xt(1),2);
for t=1:T
    % a) Importance sampling step, using SUT.
    % Loop this for all particles.
    X0 = estimated_x_a;
    
    
end    


















%x_a = [particles, v0, n0];
% estimated_x_a = [estimated_x', 0, 0]';





