%% Generate data part
clear all
clc
close all
t_max = 60;
x0 = 1; % TODO : change to random value.
[xt,yt] = generateData(t_max, x0);


%% Formulate prior
clc

%TODO: talk about this prior to Hedvig, is it to good?
number_of_samples = 1000;
x0 = 1; % TODO : change to random value.
[xt_prior,yt_prior] = generateData(number_of_samples,x0); % dim(xt) = 1x(t_max+1)

% To begin with, we set the prior to a normal distribution, generated by taking the mu and
% sigma from 1000 datapoints. 
% Another thought: maybe we should do this to get the prior but only on our
% real data points.

pd = fitdist(xt_prior,'Normal');
prior_mu = pd.mu;
prior_sigma = pd.sigma;

%% UPF Algorithm
% Repeat the experiment 100 times.
clc
% Set the number of time steps
T = 60;

% Set the number of particles
%N = 200;
N = 10;

% Step 1. t = 0.
% Draw particles from the prior
particles = normrnd(prior_mu, prior_sigma, N, 1); % 200x1
% Initiate noise variables
v0 = zeros(N,1);
n0 = zeros(N,1);
% Compute mean
estimated_x = mean(particles); % scalar
% Copute Covariance matrix.
diffs = particles - estimated_x; % 200x1
P0 = diffs'*diffs; % 1x1
% Redefine the state rand var as a concatenation of the original state and
% noise variables.
x_a = [particles, v0, n0]; % 200x3
% Compute the "new" mean
estimated_x_a = [estimated_x, mean(v0), mean(n0)]; % 1x3
% Compute the "new" Covariance matrix.
estimated_x_a_duplicates = repmat(estimated_x_a,N,1); % 200x3
diffs = x_a - estimated_x_a_duplicates; % 200x3
P0_a = diffs'*diffs; % 3x3

% Step 2. t = 1,...,60
alpha = 1;
beta = 0; % Comment from the paper: beta = 2 for suitable for Gaussian prior. Change to this?
kappa = 2; % Comment from the paper: kappa = 0 is a good default choise. Change to this?
% TODO: Adapt the content in the nestled loop to take the previous values
% in each of the t:th steps. Not only using the original values.

for t = 1 %t=1:T
    % Loop over all particle filter particles.
        % a) Importance sampling step, using SUT.
        % Calculate sigma points and their weights
        n_x = size(x_a(1,:),2);
        lambda = alpha^2 * (n_x + kappa) - n_x; 
        sqrt_matrix = sqrt((n_x+lambda)*P0_a); %3x3
        sigma_points = zeros((2*n_x+1),n_x);     
        
        sigma_points(1,:) = estimated_x_a;
        for sigma_point_i = 2:(n_x+1)
            sigma_points(sigma_point_i,:) = estimated_x_a + sqrt_matrix(sigma_point_i-1,:);
        end
        for sigma_point_i = (n_x+2):(2*n_x+1)
            sigma_points(sigma_point_i,:) = estimated_x_a - sqrt_matrix(sigma_point_i-4,:);
        end
        W0_m = lambda/(n_x+lambda);
        W0_c = lambda/(n_x+lambda) + (1 - alpha^2 + beta);
        
        
        
    % End Loop over all particle filter partcles.
end    


















%x_a = [particles, v0, n0];
% estimated_x_a = [estimated_x', 0, 0]';





